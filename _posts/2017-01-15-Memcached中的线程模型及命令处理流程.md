---
layout: post
title: Memcached中的线程模型和命令处理流程
date: 2017-01-15 00:42
categories: programming
tags: [memcached, event-based]
---

#### 线程模型
memcached中的线程模型比较通用，主线程中有一个event_loop专门监听新的连接，如果有新的连接到来则将其派给一个worker线程处理，每个worker线程自己也有一个event_loop，这个loop主要监听是否主线程派了新的连接过来，当前连接可写事件、可读事件和关闭等状态转换。还有一些辅助的线程如slab平衡线程（用来转移各个slab的空闲内存页），lru维护线程（用于促进lru中item的流动）以及lru爬虫线程(将lru中已经过期或者被flushed掉的item删除)，timeout线程（周期性的检查是否有闲置连接并将闲置连接关闭）。

##### worker线程的启动过程
1. 根据要创建的线程个数设置段锁的范围
2. 设置线程结构体
3. 创建线程，线程函数为`worker_libevent`，之后主线程调用`wait_for_thread_registration`，然后睡眠在`init_lock`上等待子线程注册完毕。同时子线程的步骤如下:
    * `worker_libevent`中每一个thread中设置单独的logger，调用`register_thread_initialized()`向主线程注册当前线程，然后进入当前线程的event_loop。
    * `register_thread_initialized`的主要工作为增加已经注册的线程个数`init_count`，然后通知主线程。如果所有的worker线程已经启动完毕，则主线程会退出`wait_for_thread_registration`。

##### 主线程向worker线程传送新的连接的流程
源码中维持一个用于存储连接信息结构体的内存池(cqi_free_list)。内存池的管理方式是，主线程负责从内存池中获取结构体，如果没有空闲的结构体则每次分配预定数目的结构体，而worker线程则负责将结构体放回内存池。取出放回的操作都需要锁保护。

1. 首先从`CQ_ITEM`内存池中分配一个新的item
2. 使用轮转法选择一个worker线程
3. 设置item中的sfd等信息，将其压入到所选的线程的待处理连接队列中
4. 向worker线程中的pipe中写入字符`c`代表有新的连接
5. worker线程中的pipe对应的文件描述符的事件回调函数`thread_libevent_process`将会被调用，在pipe中读取到的字符为`c`的情况下，则表示有新的连接，从待处理连接中取出一个`cq_item`，调用`conn_new`根据`cq_item`中的信息创建新的连接，接着将`cq_item`是放到`CQ_ITEM`内存池。
6. `conn_new`会进行以下操作：**使用连接的文件描述符索引conns指针数组**，由于连接的文件描述符是唯一的，因此这里访问全局的`conns`没有加锁，如果conns中对应的指针为`NULL`，则表示这个文件描述符从来都没有被使用过，因此为其分配`conn`结构体，接着设置连接的缓冲等信息，另外从`dispatch_conn_new`的调用可以看出所有的连接的默认事件是读事件，读事件会在此时注册到相应的`event_loop`中。**当连接释放时，conns中对应的连接结构体不会释放，而是被重复利用，只是连接结构体中的指针对应的内存会被释放或归还到相应的内存池**。

##### 连接管理

###### 连接的事件处理`event_handler`
这个函数会在`conn_new`中作为连接的事件回调函数，这个函数其中一个重要的作用是调用`drive_machine`，该函数根据当前的连接状态，使用不同的处理函数。在`dispatch_conn_new`中可以看出所有连接的初始状态是`conn_new_cmd`，也就是处于处理命令的状态，因此在连接中有数据到来时，会转到`drive_machine`的`conn_new_cmd`分支，如果此时的read_buffer还没有接收到完整的命令，则会将状态改变为`conn_waiting`等待读取更多的数据。**值得注意的是，为了防止单个连接一次处理太多的请求导致其他的连接“饿死”，源码中会对每个连接每次处理的requests个数进行限制。但是如果当前已经接受完所有的请求数据，那么除非有新的数据到来，底层的网络库将不会再通知应用层。为了解决这个问题，源码中使用了一个技巧，在处理完一定数量的请求后，为连接设置可写事件，这一般是可行的，然后在下次有可写事件时再判断是否有未处理完的请求。注意此时的连接状态仍然为conn_new_cmd，下次有可写事件时，仍然会转到这个分支**

###### 连接中的缓冲处理`try_read_network`
源码中使用的方式是每次尽可能的将连接中的数据读完（可能使用的epoll 的et模式）。但是需要**防止连接缓存内存消耗过多**，源码中限制重新分配内存的次数，如果分配的次数超过预订限制则返回。另外在**处理相邻两个请求之间会将连接的缓冲缩小的适当的大小**。

###### 对同时在线的连接数进行限制
源码中在接收新的连接时，会检查当前的连接数，如果连接数超过限制，则会给客户端发送错误消息，并将连接关闭，而不再接受新的连接。**那什么时候才能再次接受新的连接呢？源码中采用的方法是设定一个定时器(10ms)z不断的判断当前是否可以重新接受连接，判断的标准是是否有连接关闭（由`conn_close来触发`）**。

###### 处理timeout连接
使用单独的一个线程检测连接数组conns中是否有连接已经过期，如果有则向其连接所属的线程发送通知消息，同时传送相应的socket描述符。worker线程会在`thread_libevent_process`中收到通知并关闭闲置连接。


#### 命令处理流程
##### Get命令
在memcached中，在处理事件时使用的是状态机，初始状态是读取命令。只有命令处理完毕后才可能会发送数据。接下来说说两个命令get和update的处理流程。
对于get命令，会经过以下几步。
1. 初始状态在conn_new_cmd，当有数据到来时就会进入这个分支，这个分支会根据是否已经接收数据来跳转到下一个状态，如果有数据则开始进行命令解析，否则继续等待读取数据。值得注意的是在conn_new_cmd中对每次单个连接处理请求的个数有一个最大的限制，因为是基于事件机制，可能其他的连接的事件也在等待被处理，如果当前的连接事件处理时间太久则可能会导致其他连接的事件很久才被处理。但是如果当前已经把所有的请求都读取到buffer中，如果没有新的数据到来，底层的libevent是不会通知，这里memcached作者使用了一点小技巧，当出现请求没处理完但是不得不退出时，则会注册可写事件，因为可写事件一般是可行的，只要发送缓冲不满或者对方不关闭连接，应用层在下一次触发写事件时则会跳转到conn_new_cmd,再次说明，memcached处理事件是根据其当前连接的状态而不是事件类型。
2. 命令解析部分在get部分需要额外的内存来存放需要发送的数据，在memcached中使用msghdr链表来存放这些数据，一个msghdr只能存储有限的iov结构体，这里为了省去拷贝的时间，将iov结构体内的指针和长度分别设置为返回item的数据地址和长度，另外值得注意的地方是，memcached中可能随时删除这些待返回的item，而iov结构体只是使用指针和地址来标记要发送的数据并没进行拷贝，因此为了防止将待发送的item删除，memcached中对每个使用的item加了引用，并将其加入到链表ilist，这个链表的作用是在将数据发送完毕后及时的将这些item进行解引用。另外，还有一个注意的地方，每次请求都会或多或少的将每个连接的读缓冲或者msglist、ilist等扩大，因此在处理每个命令之间会将这些缓冲的大小缩小到初始大小。
3. 在将命令解析完毕并将返回数据在缓冲中标记后，会将状态设置为conn_mwrite。在conn_mwrite这个分支中，主要完成两个工作，第一步是将缓冲中标记的数据发送出去，这一步完成后则会释放缓冲以及对相关item的引用。然后又回到conn_new_cmd的状态。

##### Update命令
对于update命令来说，这一类命令其实包含set/add／replace/prepend/append等命令的实现，根据具体命令有一些不同的处理。主要有以下几步。
1. 第一步跟get命令的第一步处理一样。
2. 由于这类命令的格式是分两行输入，memcahced则是每次都只处理一行。这类命令的第一行只能知道命令的具体类型，key，flags，key的过期时间和value部分的长度。在这一步中主要是根据这些信息分配一个item。接下来会将状态设置为conn_nread。
3. conn_nread这个分支分为两步，第一步为不断地读取数据直到value部分的数据已经读完；读完value后则会调用complete_nread将value部分的数据存储在上一步中分配的item中。然后会设置状态为conn_write将命令执行的状态返回，执行完会转移到conn_new_cmd处理新的命令。
