---
layout: post
title: 深入探索C++对象模型（6）
date: 2016-12-08 16:24:36
categories: programming
tags: [C++, memory]
---

> 深入探索C++对象模型 -- 执行期语意学

#### 对象的构造和析构

- 编译器会在每个执行分支的结束位置放置相应的析构函数。在实际编程中，应该将对象的构造操作放在需要使用的位置，这样可以避免多余的对象构造和销毁工作。
- 使用静态初始化的objects(一般是全局变量或者是静态局部变量)有一些缺点，因为这些objects的初始化操作不能被放置在exception handling中，因此如果构造函数抛出异常将会导致程序直接结束。


#### new 和 delete 运算符
__operator new__
- 当要分配的大小为0时，operator new 将会分配一个字节的内存空间，并将其地址返回。
- operator new 支持用户设置`_new_handler()`，当内存分配出现错误时这个函数将会被调用。

__new 和数组__
- 对数组的分配和释放应该使用成对的格式。如`new arr[N]; ...; delete [] arr`。
- 释放数组时，应该调用数组元素的实际类型，如下所示。
```
class Point; // Base class
class Point3d; // Derived class

// 容易出错的使用方式
Point *ptr = new Point3d[10];
// 下面的释放操作将会对数组中的每个元素调用Point的析构函数，另外，这个析构函数在除了第一个元素析构在正确的起始位置，后续的元素析构的内存位置也不对，因为Base class 的大小和Derived class的大小并不一定一样。
delete [] ptr;
// 可以采取的方案是，依次对数组中每个元素(类型为Point*，实际指向Point3d对象)使用delete来启动虚拟机制，调用Point3d的析构函数，最后也会调用Point的析构函数将整个对象进行析构和释放。
```
__Placement Operator New 的语意__
Placement operator new执行以下两项操作。
- 在输入的指针所指的内存上面构造对象
- 将输入的指针返回

__值得注意的问题__
- 如果输入的指针所指的位置如果已经有对象，使用placement operator delete可以将原有对象进行析构，但是不会释放相应内存。
- 输入的指针所指的内存大小必须能够容纳的下要构造的对象。

#### 临时性对象
在C++标准中关于临时性对象在何时销毁有如下规则。
> 临时性对象的被销毁，应该是对完整表达式求值过程的最后一个步骤。该完整表达式造成临时对象的产生。(Section 12.2)

但是有两个例外。
> ... 凡持有表达式执行结果的临时性对象，应该存留到object的初始化操作完成为止。

> 如果一个临时性对象被绑定于一个reference，对象将残留，直到被初始化之的reference的生命结束，或直到临时对象的生命范畴结束，视哪一种情况先到达而定。
