---
layout: post
title: 深入探索C++对象模型（1）
date: 2016-12-03 11:24:03
categories: programming
tags: [C++, memory]
---

> 深入探索C++对象模型(1) -- 关于对象

#### 封装的成本

数据成员与C中的struct中的成员一样，成员函数虽然在class中声明，但是不在对象中占有空间。对于每个non-inline 成员函数只会产生一个函数实例，但是对于inline成员函数则会为每一个使用这个inline成员函数的**模块**产生一个函数实例。

#### C++ 对象模型

##### 简单对象模型
使用一个装有若干指针的table表征这种模型，其中每个slot中存放一个成员的地址。

##### 表格驱动对象模型
对象含有两个指向表格的指针，其中一个表格为Member Data Table，直接装有成员数据的内容；另一个表格为Function Member Table，其中每个slot中存放有每个成员函数的地址。

##### Stroustrup当初设计的C++对象模型
__基本布局__
该模型在内存空间和存取时间做了优化。
- 非静态的数据成员直接存放在对象中
- 静态的数据成员存放在对象之外
- 静态和非静态的成员函数都存放在对象之外
对于Virtual functions的支持则使用以下方式支持：
- 每个class都会产生一堆指向虚函数的指针，并将这些指针放在一个称为virtual table(vtbl)的表格中。
- 在每个对象中，都会存在一个指向相关的vitual table，通常这个指针称为vptr。vptr的设定和重置则有class中constructor、destructor和copy assignment来自动完成。每个class 所关联的type\_info object也是经由virtual table被指出来，一般可以通过vtbl中的第一个slot获得这些信息。

__继承__
在虚拟继承的情况下（将继承关系指定为virtual），那么base class不管在继承链中被派生多少次，永远也只会有一个实例。

__策略性正确的struct__
在C程序中在struct最后位置定义一个只含有一个元素的数组，在实际使用时根据需要扩充这个数组的大小，这个数组被称为柔性数组。当然能够实现这个技巧的前提是在内存中数组的位置确实在最后面，这点在C中可以保证。但是在C++中，不同的访问级别(access section)的数据在内存中的布局顺序没有规定，只规定了同一个访问级别(access section)中的数据是按照声明的顺序在内存中布局。因此，如果一定要使用这种技巧，可以在一个struct中只定义属于同一访问级别的数据成员。

##### 对象的差异
__三种程序设计范式__
- 程序模型(procedural model)，就像C一样。
- 抽象数据类型模型(abstract data type mode, ADT)，此模型所谓的抽象是由一组表达式(public 接口)提供。
- 面向对象模型(object-oriented model)，在此模型中一些相关的类型通过一个抽象的base class(用以提供共同的接口)封装起来。

__C++以下列方式支持多态__
- 经由一组隐式的转化操作，将drived class指针转化为一个base class指针。形如`shape *ps = new circle()`
- 使用virtual机制，通过指针或者引用来调用相同的基类接口，但是由于指针或者引用所指实际对象既可能是基类对象也可以是子类对象，因此实际调用的函数会根据不同的对象采用不同的操作，尽管接口都是一样。
- 使用dynamic_cast和typeid运算符来判断实际对象的类型。形如`if(circle *pc = dynamic_cast<circle*>(ps)) ...`

__指针的类型__
指向不同的类型的指针的差异，既不在其指针的表示方法不同，也不在其内容（即对象的地址）的不同，而是在于其所寻址出来的object的类型的不同。也就是，指针所指的对象类型会教导编译器如何解释莫个特定地址中的内存内容及其大小。但是对于一个`void*`的指针，由于编译器无法知道实际所指的对象类型，因此这个指针只能够持有一个地址。
在virtual机制中，使用指针调用基类的virtual函数时，得需要获得指针所指对象的类型，所指对象类型的信息存在于vptr和vtable之间。

__多态__
一个pointer或一个reference之所以能够支持多态，是因为它们并不引发内存中任何“与类型有关的内存委托操作”；会受到改变的只有它们所指内存的“大小和内容解释方式”而已。

当一个子类的对象赋值给基类变量时，将会导致子类比基类多的那部分被切割，此时多态将不再产生。比较严格的编译器则能够在编译阶段就会发现这种变化，于是能够立马解析出调用virtual的实际操作就是基类中的操作，因此virtual将不会起作用。

C++通过指针和引用来支持多态，这种程序设计风格被称为“面向对象”，C++也支持具体的ADT程序风格，如今被称为object-based。一个OB设计可能比一个对等的OO设计速度更快而且空间更加紧凑，速度快是因为所有的函数调用都会在编译时期解析完成，对象建构不需要使用virutal机制；空间紧凑则是因为每一个对象要因为要支持virtual而添加额外的负担。但是，OB的弹性不如OO。值得一说的是，现在使用funtors和bind可以使得OB的弹性更大。
